import SwiftUI
#if canImport(UIKit)
import UIKit
#endif

/// ÂçòË™ûÂÖ•Âäõ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
/// UXÊîπÂñÑ„Å´„Çà„Çä„ÄÅÈü≥Â£∞Ë™çË≠òÁµêÊûú„ÅåÂèñÂæó„Åï„Çå„ÅüÊôÇÁÇπ„ÅßËá™ÂãïÁöÑ„Å´ÈÅ∏ÊäûÁîªÈù¢„ÇíË°®Á§∫„Åó„Åæ„Åô
public struct WordInputView: View {
    public let isEnabled: Bool
    public let currentPlayerId: String  // „Éó„É¨„Ç§„É§„ÉºÂàá„ÇäÊõø„ÅàÁõ£Ë¶ñÁî®
    private let onSubmit: (String) -> Void
    
    @State private var inputText = ""
    @FocusState private var isTextFieldFocused: Bool
    @State private var settingsManager = SettingsManager.shared
    private let hiraganaConverter = HiraganaConverter()
    
    // üéØ Êñ∞„Åó„ÅÑ@ObservableÁä∂ÊÖãÁÆ°ÁêÜ„Å´„Çà„ÇãÁµ±‰∏ÄÂåñ
    @State private var speechRecognitionState = SpeechRecognitionState()
    @State private var speechManager = SpeechRecognitionManager()
    
    public init(
        isEnabled: Bool,
        currentPlayerId: String,
        onSubmit: @escaping (String) -> Void
    ) {
        AppLogger.shared.debug("WordInputViewÂàùÊúüÂåñ: enabled=\(isEnabled), playerId=\(currentPlayerId)")
        self.isEnabled = isEnabled
        self.currentPlayerId = currentPlayerId
        self.onSubmit = onSubmit
    }
    
    public var body: some View {
        VStack(spacing: DesignSystem.Spacing.standard) {
            // „Éó„É≠„Ç∞„É¨„ÉÉ„Ç∑„Éñ„Ç¨„Ç§„ÉÄ„É≥„Çπ„É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫
            if speechRecognitionState.showGuidanceMessage && !speechRecognitionState.guidanceMessage.isEmpty {
                VStack(spacing: 8) {
                    HStack(spacing: 12) {
                        // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥‰ªò„Åç„Ç¢„Ç§„Ç≥„É≥
                        Image(systemName: getGuidanceIcon())
                            .font(.title2)
                            .foregroundColor(getGuidanceColor())
                            .scaleEffect(speechRecognitionState.showGuidanceMessage ? 1.1 : 1.0)
                            .animation(.easeInOut(duration: 0.5).repeatCount(3, autoreverses: true), value: speechRecognitionState.showGuidanceMessage)
                        
                        VStack(alignment: .leading, spacing: 4) {
                            Text(getGuidanceTitle())
                                .font(.caption)
                                .fontWeight(.bold)
                                .foregroundColor(getGuidanceColor())
                            
                            Text(speechRecognitionState.guidanceMessage)
                                .font(.caption)
                                .fontWeight(.medium)
                                .foregroundColor(.primary)
                                .multilineTextAlignment(.leading)
                        }
                        
                        Spacer()
                    }
                    
                    // Â§±ÊïóÈÄ≤Êçó„Ç§„É≥„Ç∏„Ç±„Éº„Çø„ÉºÔºà3ÂõûÂ§±ÊïóÊôÇ„ÅØÈùûË°®Á§∫Ôºâ
                    if speechRecognitionState.consecutiveFailureCount < 3 {
                        HStack(spacing: 4) {
                            ForEach(1...3, id: \.self) { index in
                                Circle()
                                    .fill(index <= speechRecognitionState.consecutiveFailureCount ? getGuidanceColor() : Color.gray.opacity(0.3))
                                    .frame(width: 8, height: 8)
                                    .scaleEffect(index == speechRecognitionState.consecutiveFailureCount ? 1.2 : 1.0)
                                    .animation(.easeInOut(duration: 0.3), value: speechRecognitionState.consecutiveFailureCount)
                            }
                        }
                    }
                }
                .padding(.horizontal, DesignSystem.Spacing.standard)
                .padding(.vertical, DesignSystem.Spacing.mediumSmall)
                .background(
                    RoundedRectangle(cornerRadius: 16)
                        .fill(backgroundColorForCurrentPlatform)
                        .shadow(color: getGuidanceColor().opacity(0.2), radius: 8, x: 0, y: 4)
                        .overlay(
                            RoundedRectangle(cornerRadius: 16)
                                .stroke(getGuidanceColor().opacity(0.3), lineWidth: 2)
                        )
                )
                .transition(.asymmetric(
                    insertion: .opacity.combined(with: .scale(scale: 0.8)).combined(with: .offset(y: -20)),
                    removal: .opacity.combined(with: .scale(scale: 0.9))
                ))
                .animation(.spring(response: 0.6, dampingFraction: 0.8), value: speechRecognitionState.showGuidanceMessage)
            }
            
            // ÂÖ•Âäõ„É¢„Éº„ÉâÂàáÊõøÔºàÈü≥Â£∞ÂÖ•Âäõ„ÇíÂÑ™ÂÖàÁöÑ„Å´Ë°®Á§∫Ôºâ
            HStack(spacing: DesignSystem.Spacing.mediumLarge) {
                // Èü≥Â£∞ÂÖ•Âäõ„Éú„Çø„É≥ÔºàÂ∑¶ÂÅ¥„Å´ÈÖçÁΩÆ„Åó„Å¶ÂÑ™ÂÖàÂ∫¶„ÇíÈ´ò„ÇÅ„ÇãÔºâ
                Button(action: {
                    speechRecognitionState.isVoiceMode = true
                    isTextFieldFocused = false
                    AppLogger.shared.debug("Èü≥Â£∞ÂÖ•Âäõ„É¢„Éº„Éâ„Å´ÂàáÊõø")
                }) {
                    HStack {
                        Image(systemName: "mic.fill")
                        Text("„Åä„Çì„Åõ„ÅÑ")
                    }
                    .font(.caption)
                    .fontWeight(speechRecognitionState.isVoiceMode ? .bold : .regular)
                    .padding(.horizontal, DesignSystem.Spacing.standard)
                    .padding(.vertical, DesignSystem.Spacing.small)
                    .background(speechRecognitionState.isVoiceMode ? Color.red : Color.gray.opacity(0.3))
                    .foregroundColor(speechRecognitionState.isVoiceMode ? .white : .gray)
                    .cornerRadius(20)
                    .scaleEffect(speechRecognitionState.isVoiceMode ? 1.05 : 1.0)
                    .animation(.easeInOut(duration: 0.2), value: speechRecognitionState.isVoiceMode)
                }
                .disabled(!isEnabled)
                
                // „Ç≠„Éº„Éú„Éº„ÉâÂÖ•Âäõ„Éú„Çø„É≥ÔºàÂè≥ÂÅ¥„Å´ÈÖçÁΩÆÔºâ
                Button(action: {
                    speechRecognitionState.isVoiceMode = false
                    isTextFieldFocused = true
                    AppLogger.shared.debug("„ÉÜ„Ç≠„Çπ„ÉàÂÖ•Âäõ„É¢„Éº„Éâ„Å´ÂàáÊõø")
                }) {
                    HStack {
                        Image(systemName: "keyboard")
                        Text("„Ç≠„Éº„Éú„Éº„Éâ")
                    }
                    .font(.caption)
                    .fontWeight(speechRecognitionState.isVoiceMode ? .regular : .bold)
                    .padding(.horizontal, DesignSystem.Spacing.mediumSmall)
                    .padding(.vertical, DesignSystem.Spacing.tiny)
                    .background(speechRecognitionState.isVoiceMode ? Color.gray.opacity(0.3) : Color.blue)
                    .foregroundColor(speechRecognitionState.isVoiceMode ? .gray : .white)
                    .cornerRadius(20)
                    .scaleEffect(speechRecognitionState.isVoiceMode ? 1.0 : 1.05)
                    .animation(.easeInOut(duration: 0.2), value: speechRecognitionState.isVoiceMode)
                }
                .disabled(!isEnabled)
            }
            
            if speechRecognitionState.isVoiceMode {
                if speechRecognitionState.showRecognitionChoice {
                    // üéØ Ë™çË≠òÁµêÊûúÁ¢∫Ë™çUIÔºàËá™ÂãïË°®Á§∫Ôºâ
                    RecognitionResultView(
                        recognizedText: speechRecognitionState.recognitionResult,
                        onUseWord: {
                            AppLogger.shared.info("Ë™çË≠òÁµêÊûú„ÇíÊé°Áî®: \(speechRecognitionState.recognitionResult)")
                            useRecognitionResult()
                        },
                        onRetry: {
                            AppLogger.shared.info("Èü≥Â£∞Ë™çË≠ò„Çí„ÇÑ„ÇäÁõ¥„Åó")
                            retryVoiceRecognition()
                        }
                    )
                } else {
                    // Èü≥Â£∞ÂÖ•ÂäõUI
                    VStack(spacing: 8) {
                        ZStack {
                            // Â§±ÊïóÊôÇ„ÅÆ„Ç∑„Çß„Ç§„ÇØ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ËÉåÊôØ
                            if speechRecognitionState.consecutiveFailureCount > 0 && speechRecognitionState.consecutiveFailureCount < 3 {
                                Circle()
                                    .stroke(getGuidanceColor().opacity(0.3), lineWidth: 3)
                                    .frame(width: 120, height: 120)
                                    .scaleEffect(1.0 + (0.1 * Double(speechRecognitionState.consecutiveFailureCount)))
                                    .animation(.easeInOut(duration: 0.5).repeatCount(2, autoreverses: true), value: speechRecognitionState.consecutiveFailureCount)
                            }
                            
                            MicrophoneButton(
                                speechState: speechRecognitionState,
                                size: 100,
                                onTouchDown: {
                                    startVoiceRecording()
                                },
                                onTouchUp: {
                                    stopVoiceRecording()
                                }
                            )
                            .scaleEffect(speechRecognitionState.currentPhase.isActive ? 1.1 : 1.0)
                            .animation(.easeInOut(duration: 0.2), value: speechRecognitionState.currentPhase.isActive)
                            
                            // Â§±Êïó„Ç´„Ç¶„É≥„Çø„ÉºË°®Á§∫Ôºà„Éê„ÉÉ„Ç∏È¢®Ôºâ
                            if speechRecognitionState.consecutiveFailureCount > 0 && speechRecognitionState.consecutiveFailureCount < 3 {
                                VStack {
                                    HStack {
                                        Spacer()
                                        Circle()
                                            .fill(getGuidanceColor())
                                            .frame(width: 24, height: 24)
                                            .overlay(
                                                Text("\(speechRecognitionState.consecutiveFailureCount)")
                                                    .font(.caption2)
                                                    .fontWeight(.bold)
                                                    .foregroundColor(.white)
                                            )
                                            .offset(x: 10, y: -10)
                                            .transition(.scale.combined(with: .opacity))
                                            .animation(.spring(response: 0.4, dampingFraction: 0.6), value: speechRecognitionState.consecutiveFailureCount)
                                    }
                                    Spacer()
                                }
                                .frame(width: 100, height: 100)
                            }
                        }
                        
                        // üéØ Áä∂ÊÖã„Å´Âü∫„Å•„ÅèË°®Á§∫„É°„ÉÉ„Çª„Éº„Ç∏
                        VStack(spacing: 4) {
                            switch speechRecognitionState.currentPhase {
                            case .idle:
                                Text("„Éû„Ç§„ÇØ„Çí „Åä„Åó„Å™„Åå„Çâ „ÅØ„Å™„Åó„Å¶„Å≠")
                                    .font(.caption)
                                    .fontWeight(.medium)
                                    .foregroundColor(.secondary)
                                    .multilineTextAlignment(.center)
                            
                            case .recording:
                                Text("„Åç„ÅÑ„Å¶„ÅÑ„Åæ„Åô...")
                                    .font(.caption)
                                    .fontWeight(.medium)
                                    .foregroundColor(.red)
                                    .multilineTextAlignment(.center)
                            
                            case .processing:
                                VStack(spacing: 2) {
                                    Text("„Åã„Çì„Åå„Åà„Å¶„ÅÑ„Åæ„Åô...")
                                        .font(.caption2)
                                        .foregroundColor(.blue)
                                        .opacity(0.8)
                                    
                                    if !speechRecognitionState.partialResult.isEmpty {
                                        Text("„Äé\(speechRecognitionState.partialResult)„Äè„Åå „Åç„Åì„Åà„Çã„Åã„Å™Ôºü")
                                            .font(.caption)
                                            .fontWeight(.medium)
                                            .foregroundColor(.blue)
                                            .padding(.horizontal, DesignSystem.Spacing.small)
                                            .padding(.vertical, DesignSystem.Spacing.extraSmall)
                                            .background(
                                                RoundedRectangle(cornerRadius: 8)
                                                    .fill(Color.blue.opacity(0.1))
                                            )
                                    }
                                }
                                
                            case .resultReady:
                                // üéØ Ë™çË≠òÁµêÊûúË°®Á§∫„Éï„Çß„Éº„Ç∫ÔºàËá™ÂãïÈÅ∑ÁßªÂâç„ÅÆÁü≠ÊúüÈñìË°®Á§∫Ôºâ
                                HStack(spacing: 8) {
                                    Image(systemName: "checkmark.circle.fill")
                                        .font(.title2)
                                        .foregroundColor(.green)
                                        .scaleEffect(1.2)
                                    
                                    Text("„Äé\(speechRecognitionState.recognitionResult)„Äè„Åå „Åç„Åì„Åà„Åæ„Åó„ÅüÔºÅ")
                                        .font(.callout)
                                        .fontWeight(.bold)
                                        .foregroundColor(.green)
                                }
                                .padding(.horizontal, DesignSystem.Spacing.standard)
                                .padding(.vertical, DesignSystem.Spacing.small)
                                .background(
                                    RoundedRectangle(cornerRadius: 16)
                                        .fill(
                                            LinearGradient(
                                                colors: [Color.green.opacity(0.15), Color.mint.opacity(0.1)],
                                                startPoint: .leading,
                                                endPoint: .trailing
                                            )
                                        )
                                        .stroke(Color.green.opacity(0.4), lineWidth: 2)
                                        .shadow(color: .green.opacity(0.2), radius: 4, x: 0, y: 2)
                                )
                                .multilineTextAlignment(.center)
                                .transition(.asymmetric(
                                    insertion: .scale(scale: 0.8).combined(with: .opacity).combined(with: .offset(y: -10)),
                                    removal: .scale(scale: 1.1).combined(with: .opacity).combined(with: .offset(y: 10))
                                ))
                                .animation(.spring(response: 0.4, dampingFraction: 0.7), value: speechRecognitionState.recognitionResult)
                                
                            case .choiceDisplayed, .completed, .failed:
                                EmptyView()
                            }
                        }
                    }
                    .frame(minHeight: 140, maxHeight: 160)
                    .frame(maxWidth: .infinity)
                }
            } else {
                // „ÉÜ„Ç≠„Çπ„ÉàÂÖ•ÂäõUI
                VStack(spacing: 12) {
                    HStack {
                        TextField("„Åì„Å®„Å∞„Çí „ÅÑ„Çå„Å¶„Å≠", text: $inputText)
                            .font(.title2)
                            .padding(DesignSystem.Spacing.standard)
                            .background(
                                RoundedRectangle(cornerRadius: 12)
                                    .fill(backgroundColorForCurrentPlatform)
                                    .stroke(isEnabled ? Color.blue : Color.gray, lineWidth: 2)
                            )
                            .focused($isTextFieldFocused)
                            .disabled(!isEnabled)
                            .onSubmit {
                                submitWord()
                            }
                        
                        Button(action: {
                            guard canSubmit else { return }
                            submitWord()
                        }) {
                            Text("üÜó")
                                .font(.title2)
                                .fontWeight(.bold)
                                .foregroundColor(.white)
                                .frame(width: 60, height: 60)
                                .background(canSubmit ? Color.green : Color.gray)
                                .cornerRadius(30)
                        }
                        .disabled(!canSubmit)
                    }
                    
                    Text("„Åï„ÅÑ„Åî„ÅÆ „ÇÇ„Åò„Åã„Çâ „ÅØ„Åò„Åæ„Çã „Åì„Å®„Å∞„Çí „ÅÑ„Çå„Å¶„Å≠")
                        .font(.caption)
                        .foregroundColor(.gray)
                        .multilineTextAlignment(.center)
                }
                .frame(minHeight: 120, maxHeight: 140)
            }
        }
        .padding(DesignSystem.Spacing.standard)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.blue.opacity(0.1))
                .stroke(Color.blue.opacity(0.3), lineWidth: 1)
        )
        .opacity(isEnabled ? 1.0 : 0.6)
        .onAppear {
            initializeInputMode()
        }
        // „Éó„É¨„Ç§„É§„ÉºÂ§âÊõ¥ÊôÇ„ÅÆËá™Âãï„É™„Çª„ÉÉ„ÉàÂá¶ÁêÜ
        .onChange(of: currentPlayerId) { _, newPlayerId in
            AppLogger.shared.info("„Éó„É¨„Ç§„É§„ÉºÂàá„ÇäÊõø„ÅàÊ§úÂá∫: \(newPlayerId) - Èü≥Â£∞Ë™çË≠òÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà")
            
            // Èü≥Â£∞Ë™çË≠ò„ÅåÈÄ≤Ë°å‰∏≠„ÅÆÂ†¥Âêà„ÅØÂÆâÂÖ®„Å´ÂÅúÊ≠¢
            if speechRecognitionState.currentPhase.isActive {
                AppLogger.shared.info("ÈÄ≤Ë°å‰∏≠„ÅÆÈü≥Â£∞Ë™çË≠ò„ÇíÂÅúÊ≠¢: \(speechRecognitionState.currentPhase)")
                speechManager.stopRecording()
            }
            
            // ÂÆåÂÖ®„Å™„É™„Çª„ÉÉ„ÉàÂá¶ÁêÜÔºà‰∏°Êñπ„ÅÆ„Éû„Éç„Éº„Ç∏„É£„Éº„Çí„É™„Çª„ÉÉ„ÉàÔºâ
            speechRecognitionState.resetForNewTurn()
            speechManager.resetForNewTurn()
            inputText = ""
            isTextFieldFocused = false
            initializeInputMode()
        }
        // üéØ Áä∂ÊÖãÂ§âÊõ¥„ÅÆÁõ£Ë¶ñÔºàÈÅÖÂª∂Âá¶ÁêÜ„ÅÆ‰ª£ÊõøÔºâ
        .onChange(of: speechRecognitionState.currentPhase) { _, newPhase in
            handlePhaseChange(newPhase)
        }
    }
    
    private var canSubmit: Bool {
        isEnabled && !inputText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    
    private var backgroundColorForCurrentPlatform: Color {
        #if canImport(UIKit)
        return Color(UIColor.systemBackground)
        #else
        return Color.white
        #endif
    }
    
    private func submitWord() {
        let rawWord = inputText.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !rawWord.isEmpty else { return }
        
        // ÂÖ•Âäõ„ÇíÊ∏ÖÊµÑÂåñÔºàÁÑ°Âäπ„Å™ÊñáÂ≠ó„ÇíÈô§ÂéªÔºâ
        let wordValidator = WordValidator()
        let sanitizedWord = wordValidator.sanitizeInput(rawWord)
        
        if sanitizedWord.isEmpty {
            AppLogger.shared.warning("Ê∏ÖÊµÑÂåñÂæå„Å´Á©∫ÊñáÂ≠ó„Å´„Å™„Çä„Åæ„Åó„Åü: '\(rawWord)'")
            inputText = ""
            return
        }
        
        if sanitizedWord != rawWord {
            AppLogger.shared.info("ÂÖ•ÂäõÊ∏ÖÊµÑÂåñ: '\(rawWord)' -> '\(sanitizedWord)'")
        }
        
        // „Å≤„Çâ„Åå„Å™„Å´Â§âÊèõÔºàÊ≠£Ë¶èÂåñ„ÅØË°å„Çè„Å™„ÅÑÔºâ
        let hiraganaWord = hiraganaConverter.convertToHiragana(sanitizedWord)
        
        if hiraganaWord != sanitizedWord {
            AppLogger.shared.info("„Å≤„Çâ„Åå„Å™Â§âÊèõ: '\(sanitizedWord)' -> '\(hiraganaWord)'")
        }
        
        AppLogger.shared.info("ÂçòË™ûÊèêÂá∫: '\(hiraganaWord)'")
        onSubmit(hiraganaWord)
        inputText = ""
    }
    
    // MARK: - Voice Recognition Methods
    
    private func startVoiceRecording() {
        guard isEnabled && speechRecognitionState.currentPhase == .idle else { return }
        
        AppLogger.shared.info("üé§ Èü≥Â£∞Èå≤Èü≥ÈñãÂßã")
        speechRecognitionState.startRecording()
        inputText = ""
        
        Task {
            await speechManager.startRecording { recognizedText in
                Task { @MainActor in
                    let hiraganaText = hiraganaConverter.convertToHiragana(recognizedText)
                    
                    // ‰∏≠ÈñìÁµêÊûúÊõ¥Êñ∞ÔºàÂá¶ÁêÜ‰∏≠ÊÆµÈöéÔºâ
                    if speechRecognitionState.currentPhase == .recording {
                        speechRecognitionState.startProcessing()
                    }
                    
                    // „É™„Ç¢„É´„Çø„Ç§„É†‰∏≠ÈñìÁµêÊûú
                    speechRecognitionState.updatePartialResult(hiraganaText, confidence: 0.8) // ‰ªÆ„ÅÆ‰ø°È†ºÂ∫¶
                    inputText = hiraganaText
                }
            }
        }
    }
    
    private func stopVoiceRecording() {
        guard speechRecognitionState.currentPhase.isActive else { return }
        
        AppLogger.shared.info("üé§ Èü≥Â£∞Èå≤Èü≥ÂÅúÊ≠¢")
        speechManager.stopRecording()
        
        // üéØ Áä∂ÊÖã„Éô„Éº„Çπ„ÅÆÁµêÊûúÂá¶ÁêÜÔºàÈÅÖÂª∂„Å™„ÅóÔºâ
        let finalResult = inputText.trimmingCharacters(in: .whitespacesAndNewlines)
        
        if !finalResult.isEmpty {
            // Ë™çË≠òÊàêÂäü ‚Üí ÁµêÊûúÊ∫ñÂÇôÂÆå‰∫ÜÊÆµÈöé„Å´ÈÅ∑Áßª
            speechRecognitionState.completeRecognition(result: finalResult, confidence: 0.8)
        } else {
            // Ë™çË≠òÂ§±Êïó
            speechRecognitionState.recordFailure()
            handleVoiceRecognitionFailure()
        }
    }
    
    /// üéØ ÊÆµÈöéÂ§âÊõ¥ÊôÇ„ÅÆÂá¶ÁêÜÔºàÈÅÖÂª∂Âá¶ÁêÜ„ÅÆ‰ª£ÊõøÔºâ
    private func handlePhaseChange(_ newPhase: SpeechRecognitionState.Phase) {
        AppLogger.shared.debug("Èü≥Â£∞Ë™çË≠òÊÆµÈöéÂ§âÊõ¥ÂØæÂøú: \(newPhase)")
        
        switch newPhase {
        case .failed:
            // Â§±ÊïóÊôÇ„ÅÆÂá¶ÁêÜ
            break
        default:
            break
        }
    }
    
    /// Èü≥Â£∞Ë™çË≠òÂ§±ÊïóÊôÇ„ÅÆÂá¶ÁêÜ
    private func handleVoiceRecognitionFailure() {
        let failureCount = speechRecognitionState.consecutiveFailureCount
        
        AppLogger.shared.info("Èü≥Â£∞Ë™çË≠òÂ§±ÊïóÂá¶ÁêÜ: \(failureCount)ÂõûÁõÆ")
        
        // Ë®≠ÂÆö„Å´Âü∫„Å•„ÅÑ„Å¶Â§±ÊïóÈñæÂÄ§„ÇíÊõ¥Êñ∞
        speechManager.setFailureThreshold(settingsManager.speechFailureThreshold)
        
        // Ëá™Âãï„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊ©üËÉΩ„ÅåÊúâÂäπ„Åß„ÄÅÈñæÂÄ§„Å´ÈÅî„Åó„ÅüÂ†¥Âêà
        if settingsManager.autoFallbackEnabled &&
           speechRecognitionState.hasReachedFailureThreshold(settingsManager.speechFailureThreshold) &&
           !speechRecognitionState.hasAutoSwitched {
            speechRecognitionState.performAutoFallback()
        }
    }
    
    /// ÂàùÊúüÂåñ„É°„ÇΩ„ÉÉ„Éâ
    private func initializeInputMode() {
        let defaultMode = settingsManager.defaultInputMode
        speechRecognitionState.isVoiceMode = defaultMode
        
        AppLogger.shared.info("ÂÖ•Âäõ„É¢„Éº„Éâ„ÇíÂàùÊúüÂåñ: \(defaultMode ? "Èü≥Â£∞ÂÖ•Âäõ" : "„Ç≠„Éº„Éú„Éº„ÉâÂÖ•Âäõ")")
        
        // „Ç≠„Éº„Éú„Éº„ÉâÂÖ•Âäõ„É¢„Éº„Éâ„ÅÆÂ†¥Âêà„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„Éï„Ç£„Éº„É´„Éâ„Å´„Éï„Ç©„Éº„Ç´„Çπ
        if !defaultMode {
            isTextFieldFocused = true
        }
    }
    
    // MARK: - „Éò„É´„Éë„Éº„É°„ÇΩ„ÉÉ„Éâ
    
    /// „Ç¨„Ç§„ÉÄ„É≥„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Ç¢„Ç§„Ç≥„É≥„ÇíÂèñÂæó
    private func getGuidanceIcon() -> String {
        let failureCount = speechRecognitionState.consecutiveFailureCount
        switch failureCount {
        case 1:
            return "exclamationmark.circle"
        case 2:
            return "exclamationmark.triangle"
        case 3:
            return "keyboard"
        default:
            return "info.circle"
        }
    }
    
    /// „Ç¨„Ç§„ÉÄ„É≥„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆËâ≤„ÇíÂèñÂæó
    private func getGuidanceColor() -> Color {
        let failureCount = speechRecognitionState.consecutiveFailureCount
        switch failureCount {
        case 1:
            return .blue
        case 2:
            return .orange
        case 3:
            return .red
        default:
            return .gray
        }
    }
    
    /// „Ç¨„Ç§„ÉÄ„É≥„Çπ„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Çø„Ç§„Éà„É´„ÇíÂèñÂæó
    private func getGuidanceTitle() -> String {
        let failureCount = speechRecognitionState.consecutiveFailureCount
        switch failureCount {
        case 1:
            return "„Å°„Çá„Å£„Å®ÂæÖ„Å£„Å¶ÔºÅ"
        case 2:
            return "„Åå„Çì„Å∞„Å£„Å¶ÔºÅ"
        case 3:
            return "„Ç≠„Éº„Éú„Éº„Éâ„Çí‰Ωø„Åä„ÅÜÔºÅ"
        default:
            return "„Éí„É≥„Éà"
        }
    }
    
    /// Êñ∞„Åó„ÅÑ„Çø„Éº„É≥ÈñãÂßãÊôÇ„ÅÆÁä∂ÊÖã„É™„Çª„ÉÉ„Éà
    public func resetForNewTurn() {
        AppLogger.shared.debug("WordInputView: Êñ∞„Åó„ÅÑ„Çø„Éº„É≥„ÅÆ„Åü„ÇÅ„ÅÆ„É™„Çª„ÉÉ„Éà")
        speechRecognitionState.resetForNewTurn()
        inputText = ""
        initializeInputMode()
    }
    
    // MARK: - Voice Recognition Result Methods
    
    /// Ë™çË≠òÁµêÊûú„ÇíÊé°Áî®„Åó„Å¶ÊèêÂá∫
    private func useRecognitionResult() {
        AppLogger.shared.info("Èü≥Â£∞Ë™çË≠òÁµêÊûú„ÇíÊé°Áî®: '\(speechRecognitionState.recognitionResult)'")
        
        // ÊàêÂäü„ÇíË®òÈå≤
        speechRecognitionState.completeWithResult()
        
        // Ë™çË≠òÁµêÊûú„ÇíÂÖ•Âäõ„ÉÜ„Ç≠„Çπ„Éà„Å´Ë®≠ÂÆö
        inputText = speechRecognitionState.recognitionResult
        
        // ÂçòË™û„ÇíÊèêÂá∫
        submitWord()
    }
    
    /// Èü≥Â£∞Ë™çË≠ò„Çí„ÇÑ„ÇäÁõ¥„Åô
    private func retryVoiceRecognition() {
        AppLogger.shared.info("Èü≥Â£∞Ë™çË≠ò„Çí„ÇÑ„ÇäÁõ¥„Åó - Â§±Êïó„Å®„Åó„Å¶Ë®òÈå≤")
        speechRecognitionState.retryRecognition()
        inputText = ""
        handleVoiceRecognitionFailure()
    }
}

/// Èü≥Â£∞Ë™çË≠òÁµêÊûúÁ¢∫Ë™ç„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
private struct RecognitionResultView: View {
    let recognizedText: String
    let onUseWord: () -> Void
    let onRetry: () -> Void
    
    var body: some View {
        VStack(spacing: DesignSystem.Spacing.standard) {
            // „Ç¨„Ç§„Éâ„É°„ÉÉ„Çª„Éº„Ç∏
            Text("„Åì„ÅÆ „Åì„Å®„Å∞„Åß „ÅÑ„ÅÑ„Åã„Å™Ôºü")
                .font(.title3)
                .fontWeight(.medium)
                .foregroundColor(.primary)
                .multilineTextAlignment(.center)
            
            // Ë™çË≠òÁµêÊûú„ÇíÂ§ß„Åç„ÅèË°®Á§∫
            VStack(spacing: 8) {
                Text(recognizedText)
                    .font(.system(size: 28, weight: .bold, design: .rounded))
                    .foregroundColor(.blue)
                    .padding(.horizontal, DesignSystem.Spacing.standard)
                    .padding(.vertical, DesignSystem.Spacing.small)
                    .background(
                        RoundedRectangle(cornerRadius: 14)
                            .fill(Color.blue.opacity(0.1))
                            .stroke(Color.blue.opacity(0.3), lineWidth: 2)
                    )
                    .multilineTextAlignment(.center)
                    .lineLimit(2) // Èï∑„ÅÑ„ÉÜ„Ç≠„Çπ„Éà„Åß„ÇÇË¶ãÂàá„Çå„Å™„ÅÑ„Çà„ÅÜ„Å´Âà∂Èôê
                
                Text("„Å´„Çì„Åó„Åç „Åï„Çå„Åü „Åì„Å®„Å∞")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            // ÈÅ∏Êäû„Éú„Çø„É≥Ôºà„Ç≥„É≥„Éë„ÇØ„Éà„Å´Ë™øÊï¥Ôºâ
            HStack(spacing: 12) {
                // „ÇÑ„ÇäÁõ¥„Åô„Éú„Çø„É≥Ôºà„Çµ„Ç§„Ç∫Ë™øÊï¥Ôºâ
                Button(action: onRetry) {
                    HStack(spacing: 6) {
                        Image(systemName: "arrow.clockwise")
                            .font(.callout)
                        Text("„ÇÑ„Çä„Å™„Åä„Åô")
                            .font(.callout)
                            .fontWeight(.bold)
                    }
                    .foregroundColor(.white)
                    .padding(.horizontal, DesignSystem.Spacing.standard)
                    .padding(.vertical, DesignSystem.Spacing.small)
                    .background(
                        RoundedRectangle(cornerRadius: 20)
                            .fill(Color.orange)
                    )
                    .shadow(color: .orange.opacity(0.3), radius: 3, x: 0, y: 1)
                }
                
                // Êé°Áî®„Éú„Çø„É≥Ôºà„Çµ„Ç§„Ç∫Ë™øÊï¥Ôºâ
                Button(action: onUseWord) {
                    HStack(spacing: 6) {
                        Image(systemName: "checkmark.circle.fill")
                            .font(.title3)
                        Text("„Å§„Åã„ÅÜ")
                            .font(.callout)
                            .fontWeight(.bold)
                    }
                    .foregroundColor(.white)
                    .padding(.horizontal, DesignSystem.Spacing.mediumLarge)
                    .padding(.vertical, DesignSystem.Spacing.mediumSmall)
                    .background(
                        RoundedRectangle(cornerRadius: 22)
                            .fill(
                                LinearGradient(
                                    colors: [.green, .mint],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                    )
                    .shadow(color: .green.opacity(0.4), radius: 4, x: 0, y: 2)
                }
                .scaleEffect(1.02) // ËªΩÂæÆ„Å™Âº∑Ë™ø„ÅÆ„Åø
            }
        }
        .frame(minHeight: 160, maxHeight: 200) // È´ò„ÅïÂà∂Èôê„ÇíÁ∑©Âíå
        .frame(maxWidth: .infinity)
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        .background(
            RoundedRectangle(cornerRadius: 20)
                .fill(Color.primary.opacity(0.05))
                .stroke(Color.primary.opacity(0.1), lineWidth: 1)
        )
        .animation(.spring(response: 0.6, dampingFraction: 0.8), value: recognizedText)
    }
}