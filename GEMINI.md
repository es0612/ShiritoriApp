# Gemini 開発ガイドライン

このドキュメントは、しりとりアプリプロジェクトの開発ガイドラインと規約を定めたものです。

## 1. テスト方針 (TDD/BDD)

開発は、和田卓人氏が提唱するテスト駆動開発（TDD）の原則に従います。**開発速度を最優先するため、TDDサイクルは主に高速に実行できるユニットテストを中心に回します。**

### 1.1. 開発サイクル: Red-Green-Refactor (ユニットテスト駆動)

すべての機能開発は、以下のサイクルを基本とします。

1.  **Red:** まず、失敗する**ユニットテスト**を1つだけ書きます。このテストは、これから実装するコンポーネント（ViewModelのメソッドなど）の具体的な振る舞いを定義します。
2.  **Green:** テストをパスさせるための、**最小限かつ最もシンプルなコード**を実装します。
3.  **Refactor:** テストがパスしている状態を維持しながら、コードの重複をなくし、可読性を向上させるリファクタリングを行います。

この高速なサイクルを繰り返すことで、内部品質を確保しながらスピーディに開発を進めます。

### 1.2. テストの役割分担

- **ユニットテスト (TDDの中心):**
    - **目的:** 開発のスピードと内部品質の担保。
    - **対象:** ViewModel、ロジック、モデルなど、UIから独立したコンポーネント。
    - **実行頻度:** コーディング中に常時実行。

- **UIテスト / 受け入れテスト (BDDのガイド):
    - **目的:** 機能全体の振る舞いが、ユーザーの期待通りであることを保証する。
    - **対象:** 画面遷移、UI要素の表示・操作など、ユーザーシナリオ全体。
    - **方針:** これらのテストは実行に時間がかかるため、TDDの高速なサイクルには含めません。機能開発の節目や、コミット前、CI/CDパイプラインでの実行を想定します。開発中は、これらのテストが最終的なゴールを示す「仕様書」として機能します。

### 1.3. 具体的な開発フロー

```
┌──────────────────────────┐
│ 1. (必要なら)受け入れテストを書く │
│    (CIで実行/手動実行)         │
└────────────┬─────────────┘
             │
┌────────────▼─────────────┐
│ 2. ユニットテストを書く (Fail) │  <--┐
└────────────┬─────────────┘   │
             │                   │
┌────────────▼─────────────┐   │
│ 3. 実装コードを書く (Pass)   │   │ Fast TDD Loop
└────────────┬─────────────┘   │
             │                   │
┌────────────▼─────────────┐   │
│ 4. リファクタリングする      │   │
└────────────┬─────────────┘   │
             │                   │
┌────────────▼─────────────┐   │
│ 5. (次の機能へ) ------------┘
└──────────────────────────┘
```


## 2. 開発技術スタック

- **主要言語:** Swift
- **UIフレームワーク:** SwiftUI
- **テストフレームワーク:** Swift Testing (`import Testing`)
- **データ永続化:** SwiftData

## 3. コーディング規約

### 3.1. 全般
- **最新のベストプラクティス:** SwiftおよびSwiftUIの進化に追従し、常に最新のベストプラクティス（例: `@Observable`マクロの活用）を積極的に採用します。
- **フォーマット:** 標準のSwiftフォーマットガイドラインに従い、Xcodeのデフォルトフォーマットを適用します。
- **命名規則:** 変数、関数、クラスには、その役割が明確にわかる説明的な名前を使用します (例: `PlayerSelectionView`, `gameViewModel`)。
- **コメント:** コードの「何」を説明するだけでなく、複雑なロジックやその実装に至った「なぜ」を説明するためにコメントを追加します。

### 3.2. SwiftUI View ルール

#### 3.2.1. Viewの責務とアーキテクチャ

- **Viewの責務:** Viewの責務は、状態(`State`)を描画することと、ユーザーからのイベントをViewModelに通知することのみとします。View自身にビジネスロジックを含めないでください。
- **Clean Architecture準拠:** Viewは**Presentation Layer**に位置し、ビジネスロジックを含まない状態の関数として実装します。副作用（ユーザーアクション、ライフサイクルイベント）は**Interactor**に転送します。
- **依存性注入:** ViewModelや状態（AppState + Interactors）は`@Environment`を使用して注入し、密結合を避けます。

#### 3.2.2. View構造設計

- **小さなView:** 1つのViewは小さく保ち、機能ごとにファイルを分割します。複雑なViewは、複数の小さなサブViewに分割して組み合わせます。
- **Layout重視:** StackView（`HStack`, `VStack`, `ZStack`）の組み合わせでレイアウトを構築し、`frame()`や`position()`などの明示的配置は最小限に抑えます。
- **カスタムLayout:** 複雑なレイアウトが必要な場合は、`Layout`プロトコルを実装したカスタムレイアウトの作成を検討します。

#### 3.2.3. コンポーネント設計

- **再利用可能性:** 共通のUIパターンはカスタムViewやViewModifierとして抽出し、再利用可能にします。
- **プロパティ注入:** 外部からの値はプロパティ（`@Binding`, 通常のプロパティ）で受け取り、直接的な状態変更は避けます。
- **コンテナView:** データの取得や変換が必要な場合は、プレゼンテーション専用のViewと分離し、コンテナViewパターンを使用します。

#### 3.2.4. 状態管理

- **Observable活用:** ViewModelや共有される参照型の状態は、`@Observable`マクロを使用して定義します。
- **適切な状態選択:** View固有の単純な値の状態管理には`@State`や`@Binding`を使用し、データの流れを単一方向に保ちます。
- **状態の責務分離:** 小さなデータは`AppState`、大容量データやデータベースからの情報は`Binding`を使用して適切に分離します。

#### 3.2.5. 開発・検証

- **プレビューの活用:** `Preview`を積極的に活用し、様々な状態やデバイスサイズでUIを検証しながら開発を進めます。
- **`body`プロパティ:** `body`の中にはロジックを記述せず、Viewの構造のみを宣言的に記述します。`body`が複雑になる場合は、`private`な`var`やメソッドとして切り出すことを検討します。
- **アクセシビリティ:** すべてのUIコンポーネントに適切なアクセシビリティラベル（`accessibilityLabel`）や役割（`accessibilityElement`）を設定します。

## 4. 高度なロギング

デバッグや品質向上のため、以下の仕様で高度なロギング機構を導入します。**バグの発見と問題の特定を最優先とし、細かいレベルでロギングを行います。**

### 4.1. ロギングクラス設計

- **ロギングクラス:** アプリ全体で利用するシングルトンな`Logger`クラスを作成します。
- **ログレベル:** `debug`, `info`, `warning`, `error` などのログレベルを定義します。
- **出力形式:** `[レベル] [日時] [ファイル:行数] [関数名] - メッセージ` のような形式で出力し、追跡しやすくします。

### 4.2. 詳細ロギング戦略

**コンソールから問題を即座に特定できるよう、以下の粒度で細かくロギングを実装します：**

#### 4.2.1. UI・ユーザー操作ログ

- **画面遷移:** どの画面からどの画面へ遷移したか（遷移理由、パラメータ含む）
- **ユーザー操作:** ボタンのタップ、スワイプ、テキスト入力など全ての操作
- **フォーカス変更:** どのUI要素がフォーカスを得た/失ったか
- **レイアウト変更:** 画面回転、サイズ変更時のレイアウト再計算
- **アニメーション:** 開始/終了タイミング、継続時間、パフォーマンス

#### 4.2.2. データ・状態変更ログ

- **状態変更:** ViewModel内の重要な状態がどのように変化したか（変更前後の値を含む）
- **データバインディング:** `@State`, `@Binding`, `@ObservedObject`の変更追跡
- **SwiftData操作:** モデルの作成、更新、削除、クエリ実行
- **メモリ使用量:** オブジェクトの生成/解放、メモリリーク検出

#### 4.2.3. ビジネスロジック詳細ログ

- **しりとり判定:** 単語の入力、辞書検索、ルール適用、結果判定の各ステップ
- **ゲーム進行:** ターン管理、スコア計算、勝敗判定
- **入力検証:** バリデーション処理の詳細（成功/失敗理由）
- **計算処理:** 重要な計算の入力値、中間結果、最終結果

#### 4.2.4. システム・パフォーマンスログ

- **パフォーマンス:** 処理時間、メモリ使用量、CPU使用率
- **ネットワーク:** API呼び出し、レスポンス時間、データサイズ
- **非同期処理:** Task、async/await、Publisher/Subscriber の実行状況
- **エラー:** `catch`したエラーや、API通信の失敗、予期しない動作

### 4.3. 実装ガイドライン

#### 4.3.1. ロギングの粒度

- **関数の開始/終了:** 重要な関数の入口と出口にログを配置
- **条件分岐:** if文、switch文の各分岐でログを出力
- **ループ処理:** 重要な繰り返し処理の回数と進行状況
- **非同期処理:** async/await、Task、Timer の開始/完了/エラー

#### 4.3.2. デバッグ効率化

- **ログ検索:** 機能別、レベル別に検索しやすいキーワードを含める
- **コンテキスト情報:** ユーザーID、セッション情報、デバイス情報を含める
- **スタックトレース:** エラー発生時の詳細な呼び出し履歴
- **パフォーマンス計測:** 処理時間の計測とボトルネック特定

#### 4.3.3. 本番環境対応

- **ログレベル制御:** 本番環境では`error`と`warning`のみ、開発環境では`debug`まで出力
- **センシティブ情報:** パスワード、トークン、個人情報は絶対にログに出力しない
- **ログローテーション:** ログファイルのサイズ制限と古いログの自動削除

## 5. データ永続化

- **フレームワーク:** `SwiftData`をプライマリな永続化手段とします。
- **モデル定義:** `@Model`マクロを使用してモデルを定義します。
- **操作:** データのCRUD操作は、ドメインロジックと分離されたリポジトリ層やサービスクラスで実行することを検討します。
