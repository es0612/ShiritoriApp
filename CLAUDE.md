# Claude 開発ガイドライン

このドキュメントは、しりとりアプリプロジェクトを開発する際の、AIアシスタント（Claude）に対する指示書です。必ずこのガイドラインに従って開発を進めてください。

## 1. テスト方針 (TDD/BDD)

開発は、和田卓人氏が提唱するテスト駆動開発（TDD）の原則に従います。**開発速度を最優先するため、TDDサイクルは主に高速に実行できるユニットテストを中心に回します。**

### 1.1. 開発サイクル: Red-Green-Refactor (ユニットテスト駆動)

すべての機能開発は、以下のサイクルを基本とします。

1.  **Red:** まず、失敗する**ユニットテスト**を1つだけ書きます。このテストは、これから実装するコンポーネント（ViewModelのメソッドなど）の具体的な振る舞いを定義します。
2.  **Green:** テストをパスさせるための、**最小限かつ最もシンプルなコード**を実装します。
3.  **Refactor:** テストがパスしている状態を維持しながら、コードの重複をなくし、可読性を向上させるリファクタリングを行います。

この高速なサイクルを繰り返すことで、内部品質を確保しながらスピーディに開発を進めます。

### 1.2. テストの役割分担

- **ユニットテスト (TDDの中心):**
    - **目的:** 開発のスピードと内部品質の担保。
    - **対象:** ViewModel、ロジック、モデルなど、UIから独立したコンポーネント。
    - **実行頻度:** コーディング中に常時実行。

- **UIテスト / 受け入れテスト (BDDのガイド):
    - **目的:** 機能全体の振る舞いが、ユーザーの期待通りであることを保証する。
    - **対象:** 画面遷移、UI要素の表示・操作など、ユーザーシナリオ全体。
    - **方針:** これらのテストは実行に時間がかかるため、TDDの高速なサイクルには含めません。機能開発の節目や、コミット前、CI/CDパイプラインでの実行を想定します。開発中は、これらのテストが最終的なゴールを示す「仕様書」として機能します。

### 1.3. 具体的な開発フロー

```
┌──────────────────────────┐
│ 1. (必要なら)受け入れテストを書く │
│    (CIで実行/手動実行)         │
└────────────┬─────────────┘
             │
┌────────────▼─────────────┐
│ 2. ユニットテストを書く (Fail) │  <--┐
└────────────┬─────────────┘   │
             │                   │
┌────────────▼─────────────┐   │
│ 3. 実装コードを書く (Pass)   │   │ Fast TDD Loop
└────────────┬─────────────┘   │
             │                   │
┌────────────▼─────────────┐   │
│ 4. リファクタリングする      │   │
└────────────┬─────────────┘   │
             │                   │
┌────────────▼─────────────┐   │
│ 5. (次の機能へ) ------------┘
└──────────────────────────┘
```


## 2. 開発技術スタック

- **主要言語:** Swift
- **UIフレームワーク:** SwiftUI
- **テストフレームワーク:** Swift Testing (`import Testing`)
- **データ永続化:** SwiftData

## 3. コーディング規約

### 3.1. 全般
- **最新のベストプラクティス:** SwiftおよびSwiftUIの進化に追従し、常に最新のベストプラクティス（例: `@Observable`マクロの活用）を積極的に採用します。
- **フォーマット:** 標準のSwiftフォーマットガイドラインに従い、Xcodeのデフォルトフォーマットを適用します。
- **命名規則:** 変数、関数、クラスには、その役割が明確にわかる説明的な名前を使用します (例: `PlayerSelectionView`, `gameViewModel`)。
- **コメント:** コードの「何」を説明するだけでなく、複雑なロジックやその実装に至った「なぜ」を説明するためにコメントを追加します。

### 3.2. SwiftUI View ルール

#### 3.2.1. Viewの責務とアーキテクチャ

- **Viewの責務:** Viewの責務は、状態(`State`)を描画することと、ユーザーからのイベントをViewModelに通知することのみとします。View自身にビジネスロジックを含めないでください。
- **Clean Architecture準拠:** Viewは**Presentation Layer**に位置し、ビジネスロジックを含まない状態の関数として実装します。副作用（ユーザーアクション、ライフサイクルイベント）は**Interactor**に転送します。
- **依存性注入:** ViewModelや状態（AppState + Interactors）は`@Environment`を使用して注入し、密結合を避けます。

#### 3.2.2. View構造設計

- **小さなView:** 1つのViewは小さく保ち、機能ごとにファイルを分割します。複雑なViewは、複数の小さなサブViewに分割して組み合わせます。
- **Layout重視:** StackView（`HStack`, `VStack`, `ZStack`）の組み合わせでレイアウトを構築し、`frame()`や`position()`などの明示的配置は最小限に抑えます。
- **カスタムLayout:** 複雑なレイアウトが必要な場合は、`Layout`プロトコルを実装したカスタムレイアウトの作成を検討します。

#### 3.2.3. コンポーネント設計

- **再利用可能性:** 共通のUIパターンはカスタムViewやViewModifierとして抽出し、再利用可能にします。
- **プロパティ注入:** 外部からの値はプロパティ（`@Binding`, 通常のプロパティ）で受け取り、直接的な状態変更は避けます。
- **コンテナView:** データの取得や変換が必要な場合は、プレゼンテーション専用のViewと分離し、コンテナViewパターンを使用します。

#### 3.2.4. 状態管理

- **Observable活用:** ViewModelや共有される参照型の状態は、`@Observable`マクロを使用して定義します。
- **適切な状態選択:** View固有の単純な値の状態管理には`@State`や`@Binding`を使用し、データの流れを単一方向に保ちます。
- **状態の責務分離:** 小さなデータは`AppState`、大容量データやデータベースからの情報は`Binding`を使用して適切に分離します。

#### 3.2.5. 開発・検証

- **プレビューの活用:** `Preview`を積極的に活用し、様々な状態やデバイスサイズでUIを検証しながら開発を進めます。
- **`body`プロパティ:** `body`の中にはロジックを記述せず、Viewの構造のみを宣言的に記述します。`body`が複雑になる場合は、`private`な`var`やメソッドとして切り出すことを検討します。
- **アクセシビリティ:** すべてのUIコンポーネントに適切なアクセシビリティラベル（`accessibilityLabel`）や役割（`accessibilityElement`）を設定します。

## 4. 高度なロギング

デバッグや品質向上のため、以下の仕様で高度なロギング機構を導入します。

- **ロギングクラス:** アプリ全体で利用するシングルトンな`Logger`クラスを作成します。
- **ログレベル:** `debug`, `info`, `warning`, `error` などのログレベルを定義します。
- **ログ内容:**
  - **画面遷移:** どの画面からどの画面へ遷移したか。
  - **ユーザー操作:** ボタンのタップなど、主要なユーザーアクション。
  - **状態変更:** ViewModel内の重要な状態がどのように変化したか。
  - **ビジネスロジック:** しりとりの判定結果など、コアなロジックの入出力。
  - **エラー:** `catch`したエラーや、API通信の失敗など。
- **出力形式:** `[レベル] [日時] [ファイル:行数] [関数名] - メッセージ` のような形式で出力し、追跡しやすくします。

## 5. データ永続化

- **フレームワーク:** `SwiftData`をプライマリな永続化手段とします。
- **モデル定義:** `@Model`マクロを使用してモデルを定義します。
- **操作:** データのCRUD操作は、ドメインロジックと分離されたリポジトリ層やサービスクラスで実行することを検討します。
